<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    

    <script>

        // 1초 마다 1씩 증가하는 숫자 출력 함수
        let count = 0;
        const countUp = () => {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    count++;
                    console.log("count : ", count);
                    resolve(count);
                }, 1000)
            })
        }

        // Promise.then() 체이닝 방식
        countUp().then((num) => {
            countUp().then((num) => {
                countUp().then((num) => {
                    countUp().then((num) => {
                        countUp().then((num) => {});
                    });
                });
            });
        });

        // 이런 방식을 "콜백 지옥(callback hell)"이라고 부른다.
        // 가독성이 매우 떨어지고, 유지보수도 어렵다.
        // 100까지 증가시키려면?

        // async / await가 등장
        //  - async, await는 Promise 기반의 비동기 코드를
        //    마치 동기 코드처럼 작성할 수 있게 해주는 키워드이다!
        //  - await는 함수의 호출 앞에 사용한다!
        //  - async는 함수를 생성할 때 사용한다!
        //  ※ 이 두 키워드는 sugar syntax(문법 설탕)
        //     즉, 기존의 Promise 객체 처리를 편하게 할 수 있도록
        //     도와주는 역할로 만들어진 문법이지, 내부적으로는 동일하게 처리



    </script>

</body>
</html>